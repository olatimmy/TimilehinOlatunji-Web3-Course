** contains duplicate

input: num = [1,2,3,1]
output: true

input: num = [1,2,3,4]
output: false


u could use 
brute force and compare each 		O n2  	 S 1
sort and compare 			O nlogn  S 1
use hashmap				O n	 S n

hashset = set()

for n in num:
	if n in hashset:
		return True
	hashset.add(n)
return false





** Is Anagram
Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.

Example 1:

Input: s = "racecar", t = "carrace"

Output: true
Example 2:

Input: s = "jar", t = "jam"

Output: false
Constraints:

s and t consist of lowercase English letters.


class Solution:
    def isAnagram(self, s: str, t: str) -> bool:

        countS, countT = {}, {}

        if len(s) != len(t):
            return False

        for i in range(len(s)):
            countS[s[i]] = 1 + countS.get(s[i], 0)
            countT[t[i]] = 1 + countT.get(t[i], 0)
        
        for c in countS:
            if countS[c] != countT.get(c,0):
                return False
        return True




****  Two Integer Sum
Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.

You may assume that every input has exactly one pair of indices i and j that satisfy the condition.

Return the answer with the smaller index first.

Example 1:

Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
Explanation: nums[0] + nums[1] == 7, so we return [0, 1].

Example 2:

Input: nums = [4,5,6], target = 10

Output: [0,2]
Example 3:

Input: nums = [5,5], target = 10

Output: [0,1]
Constraints:

2 <= nums.length <= 1000
-10,000,000 <= nums[i] <= 10,000,000
-10,000,000 <= target <= 10,000,000


class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        num_to_index = {}
        # Iterate over the array
        for i, num in enumerate(nums):
            # Calculate the complement
            complement = target - num
            # Check if complement is already in the dictionary
            if complement in num_to_index:
                return [num_to_index[complement], i]
            # Store the current number and its index in the dictionary
            num_to_index[num] = i


using recursion

def recursive_two_sum(nums, target, i=0):
    # Base case: If we reach the end of the array, stop
    if i >= len(nums) - 1:
        return None
    
    # Recursive case: Check if any of the subsequent elements with nums[i] equal to target
    for j in range(i + 1, len(nums)):
        if nums[i] + nums[j] == target:
            return [i, j]
    
    # Recursive call: Move to the next index
    return recursive_two_sum(nums, target, i + 1)

# Example usage
nums = [3, 4, 5, 6]
target = 7
print(recursive_two_sum(nums, target))  # Output: [0, 1]


mine

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        out = []
        for i in len(nums):
            j = target - nums[i]
            if j in nums:
                out.append(i)
                out.append(nums.index(j))
        return out

        







Anagram Groups
Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.

Example 1:

Input: strs = ["act","pots","tops","cat","stop","hat"]

Output: [["hat"],["act", "cat"],["stop", "pots", "tops"]]
Example 2:

Input: strs = ["x"]

Output: [["x"]]
Example 3:

Input: strs = [""]

Output: [[""]]
Constraints:

1 <= strs.length <= 1000.
0 <= strs[i].length <= 100
strs[i] is made up of lowercase English letters.






class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = defaultdict(list)

        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord("a")] += 1
            ans[tuple(count)].append(s)
        return ans.values()






































The line for i, num in enumerate(nums): is a Python loop that iterates over the nums list, but it does two things at the same time:

enumerate(nums):

enumerate() is a built-in Python function that adds a counter (index) to an iterable, like a list. It returns both the index and the element as a pair (tuple) for each iteration.
So, enumerate(nums) generates pairs like (0, nums[0]), (1, nums[1]), (2, nums[2]), ... where 0, 1, 2... are the indices of the elements in the nums list.
for i, num:

This is a loop where i represents the index of the current element, and num represents the value of the element at that index.
The for loop unpacks each pair returned by enumerate(nums) into the index (i) and the value (num).
Example:

nums = [3, 4, 5, 6]

for i, num in enumerate(nums):
    print(f"Index: {i}, Number: {num}")
This will output:


Index: 0, Number: 3
Index: 1, Number: 4
Index: 2, Number: 5
Index: 3, Number: 6
So, in the context of the problem, the loop gives access to both the index (i) and the value (num) for each element in the nums list as you iterate over it.


   


C:\Users\user\PycharmProjects\First

